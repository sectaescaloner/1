name: Hydra-V52-Safe-Report-Eternal
on:
  workflow_dispatch:
    inputs:
      token:
        description: 'Token de cuenta'
        required: true
      canal_id:
        description: 'ID del Canal objetivo'
        required: true
      comando:
        description: 'Comando activaci√≥n'
        default: '!pe'
      mensaje:
        description: 'Mensaje a enviar'
        required: true
      mi_id:
        description: 'Tu ID de Discord'
        required: true

jobs:
  execute:
    runs-on: windows-latest
    steps:
    - name: 1. Checkout
      uses: actions/checkout@v4

    - name: 2. Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: 3. Install Dependencies
      run: npm install discord.js-selfbot-v13 debug timers werift-rtp

    - name: 4. Create index.js
      shell: bash
      run: |
        cat <<EOF > index.js
        const { Client } = require('discord.js-selfbot-v13');
        const { setTimeout: wait } = require('timers/promises');

        const config = {
          token: "${{ github.event.inputs.token }}",
          targetChannel: "${{ github.event.inputs.canal_id }}",
          cmd: "${{ github.event.inputs.comando }}",
          msg: "${{ github.event.inputs.mensaje }}",
          owner: "${{ github.event.inputs.mi_id }}"
        };

        const client = new Client({ checkUpdate: false });
        let isSpamming = false;
        let lastMsgTime = Date.now();
        let totalSent = 0;

        // PROTECCI√ìN TOTAL: Evita que el proceso muera por errores
        process.on('unhandledRejection', (reason) => { console.log('üõ°Ô∏è Rejection Ignorada: ' + reason); });
        process.on('uncaughtException', (err) => { console.log('üõ°Ô∏è Exception Ignorada: ' + err); });

        client.on('ready', async () => {
            console.log("üíé Hydra V52 ETERNAL | Usuario: " + client.user.tag);
            
            // ACCI√ìN DE TESTEO: Reporte real cada 4 horas
            setInterval(async () => {
                try {
                    const ch = await client.channels.fetch(config.targetChannel).catch(() => null);
                    if (!ch) return;
                    const messages = await ch.messages.fetch({ limit: 10 }).catch(() => null);
                    if (messages && messages.size > 0) {
                        const target = messages.filter(m => m.author.id !== client.user.id).first();
                        if (target) {
                            console.log("üõ†Ô∏è Testeo: Enviando reporte de prueba por Harassment...");
                            // Intenta reportar de verdad. Si falla, el .catch lo silencia.
                            await target.report('harassment').catch(() => console.log("‚ö†Ô∏è Reporte de prueba ignorado por la API."));
                        }
                    }
                } catch(e) { /* Seguir trabajando pase lo que pase */ }
            }, 14400000);

            // MONITOR DE INACTIVIDAD: 60 seg
            setInterval(async () => {
                if (!isSpamming && (Date.now() - lastMsgTime) > 60000) {
                    const ch = await client.channels.fetch(config.targetChannel).catch(() => null);
                    if (ch) {
                        console.log("üí§ Re-activando ciclo por inactividad...");
                        const t = await ch.send(config.cmd).catch(() => null);
                        if (t) setTimeout(() => t.delete().catch(()=> {}), 1000);
                        startSpam(ch);
                    }
                }
            }, 15000);
        });

        client.on('messageCreate', async (m) => {
            if (m.channel.id !== config.targetChannel) return;
            if (m.author.id !== client.user.id) {
                lastMsgTime = Date.now();
                if (!isSpamming) startSpam(m.channel);
            }
            if (m.author.id === config.owner && m.content === config.cmd) startSpam(m.channel);
        });

        async function startSpam(channel) {
            if (isSpamming) return;
            isSpamming = true;

            while (isSpamming) {
                try {
                    // Intervalo Organico (2s a 3.03s)
                    const delay = Math.floor(Math.random() * (3030 - 2000 + 1)) + 2000;
                    await wait(delay);
                    
                    await channel.send(config.msg);
                    totalSent++;
                    lastMsgTime = Date.now();

                    // Descanso Humano cada 80 mensajes para enfriar la API
                    if (totalSent % 80 === 0) {
                        console.log("üìä Mensajes: " + totalSent + ". Pausa de seguridad...");
                        await wait(Math.floor(Math.random() * (100000 - 50000 + 1)) + 50000);
                    }
                } catch (e) {
                    if (e.code === 429) await wait(65000); // Rate Limit de Discord
                    else { isSpamming = false; break; }
                }
            }
        }

        client.login(config.token).catch(() => process.exit(1));
        EOF

    - name: 5. Relevo de Credenciales y Anti-Cuelgue
      shell: bash
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Bucle de resurrecci√≥n Bash: Si el bot se cuelga, se reinicia solo.
        (
          until node index.js; do
            echo "‚ö†Ô∏è El bot se cerr√≥. Reiniciando proceso de inmediato..."
            sleep 2
          done
        ) &
        
        # Espera de 5 horas y 55 minutos (21300 segundos)
        sleep 21300
        
        echo "üö® PRIORIDAD: Traspasando credenciales al siguiente Runner..."
        # 5 Intentos de relevo con espera de 30s para asegurar continuidad
        for i in {1..5}; do
          gh workflow run main.yml \
            -f token="${{ github.event.inputs.token }}" \
            -f canal_id="${{ github.event.inputs.canal_id }}" \
            -f comando="${{ github.event.inputs.comando }}" \
            -f mensaje="${{ github.event.inputs.mensaje }}" \
            -f mi_id="${{ github.event.inputs.mi_id }}" && break || sleep 30
        done
        
        echo "‚úÖ Relevo completado. Finalizando runner anterior."
        sleep 300
        
