name: SOLO_RUSTDESK
on:
  workflow_dispatch:
    inputs:
      runtime_minutes:
        description: "Tiempo de encendido (minutos, max 360)"
        required: false
        default: "355"

jobs:
  rdp:
    runs-on: windows-latest
    timeout-minutes: 370
    steps:
      - name: 1. Instalar RustDesk (MSI)
        shell: pwsh
        run: |
          $rdExe = "C:\Program Files\RustDesk\rustdesk.exe"
          if (-not (Test-Path $rdExe)) {
            Write-Host "Descargando e instalando RustDesk..."
            $rdUrl = "https://github.com/rustdesk/rustdesk/releases/download/1.3.1/rustdesk-1.3.1-x86_64.msi"
            $installerPath = "$env:TEMP\rustdesk.msi"
            Invoke-WebRequest -Uri $rdUrl -OutFile $installerPath
            Start-Process msiexec.exe -ArgumentList "/i","`"$installerPath`"","/quiet","/norestart" -Wait
            Remove-Item $installerPath -Force
          }
          Write-Host "RustDesk instalado correctamente."

      - name: 2. Abrir Puertos en Firewall
        shell: pwsh
        run: |
          Write-Host "Configurando Firewall para RustDesk..."
          for ($p=21115; $p -le 21119; $p++) {
            netsh advfirewall firewall add rule name="RustDesk-TCP-$p" dir=in action=allow protocol=TCP localport=$p
          }
          netsh advfirewall firewall add rule name="RustDesk-UDP-21116" dir=in action=allow protocol=UDP localport=21116

      - name: 3. Lanzar RustDesk y Capturar ID
        shell: pwsh
        run: |
          $rdExe = "C:\Program Files\RustDesk\rustdesk.exe"
          # Iniciar RustDesk
          Start-Process -FilePath $rdExe
          Write-Host "Esperando 10 segundos para que genere el ID..."
          Start-Sleep -Seconds 10

          # Tomar captura de pantalla para ver el ID y Password
          $screenshotPath = "$env:TEMP\rustdesk_access.png"
          Add-Type -AssemblyName System.Windows.Forms
          Add-Type -AssemblyName System.Drawing
          $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
          $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
          $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
          $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
          $bitmap.Save($screenshotPath, [System.Drawing.Imaging.ImageFormat]::Png)
          $graphics.Dispose(); $bitmap.Dispose()

          # Subir captura a Gofile
          Write-Host "Subiendo captura a Gofile..."
          $curlResult = curl.exe -F "file=@$screenshotPath" https://store1.gofile.io/uploadFile
          $json = $curlResult | ConvertFrom-Json
          if ($json.status -eq "ok") { 
            Write-Host "========================================"
            Write-Host "üîó VER ID Y PASS AQU√ç: $($json.data.downloadPage)"
            Write-Host "========================================"
          } else {
            Write-Error "Fallo al subir la imagen a Gofile."
          }

      - name: 4. Mantener Vivo
        shell: pwsh
        run: |
          $mins = [int]"${{ inputs.runtime_minutes }}"
          $end = (Get-Date).AddMinutes($mins)
          Write-Host "Runner activo por $mins minutos. Finaliza a las: $($end.ToString('HH:mm:ss'))"
          while ((Get-Date) -lt $end) {
            Write-Host "Heartbeat $(Get-Date) - No cerrar esta pesta√±a"
            Start-Sleep -Seconds 60
          }
          
